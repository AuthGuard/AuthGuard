package com.authguard.jwt.oauth.service;

import com.authguard.config.ConfigContext;
import com.authguard.dal.SessionsRepository;
import com.authguard.dal.model.SessionDO;
import com.authguard.jwt.oauth.OAuthServiceClient;
import com.authguard.jwt.oauth.ResponseType;
import com.authguard.jwt.oauth.TokensResponse;
import com.authguard.jwt.oauth.config.ImmutableOAuthClientConfiguration;
import com.authguard.jwt.oauth.config.ImmutableOAuthConfiguration;
import com.authguard.service.exceptions.ServiceAuthorizationException;
import com.authguard.service.exceptions.ServiceException;
import com.authguard.service.exceptions.codes.ErrorCode;
import com.google.common.collect.Maps;
import com.google.inject.Inject;
import com.google.inject.name.Named;

import java.time.Duration;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

public class OAuthService {
    private final Map<String, OAuthServiceClient> providersClients;
    private final SessionsRepository sessionsRepository; // temporary until we have a sessions service
    private final Duration stateTtl;

    @Inject
    public OAuthService(final @Named("oauth") ConfigContext configContext, final SessionsRepository sessionsRepository) {
        this(configContext.asConfigBean(ImmutableOAuthConfiguration.class), sessionsRepository);
    }

    public OAuthService(final ImmutableOAuthConfiguration configuration, final SessionsRepository sessionsRepository) {
        this.sessionsRepository = sessionsRepository;

        this.providersClients = createClients(configuration.getClients());
        this.stateTtl = Duration.ofMinutes(5);
    }

    /**
     * Creates an authorization URL to be sent to the client to redirect
     * it to the identity provider authorization page. It generates a
     * new temporary session to store the state to be verified later.
     *
     * @param provider The name of a provider as stated in the configuration.
     */
    public CompletableFuture<String> getAuthorizationUrl(final String provider) {
        final OAuthServiceClient client = Optional.ofNullable(providersClients.get(provider))
                .orElseThrow(() -> new ServiceException(ErrorCode.GENERIC_AUTH_FAILURE, "Invalid identity provider"));
        final String state = StateCodes.create();
        final SessionDO session = SessionDO.builder()
                .id(state)
                .expiresAt(ZonedDateTime.now().plus(stateTtl))
                .build();

        return sessionsRepository.save(session)
                .thenApply(created -> client.createAuthorizationUrl(state, ResponseType.CODE));
    }

    /**
     * Exchanges an authorization code with OAuth tokens. It'll verify that
     * a session containing that state exists before performing the exchange.
     * If the state has expired or no record of it existed then the future
     * will complete with {@link ServiceAuthorizationException}.
     *
     * @param provider The name of a provider as stated in the configuration.
     * @param state The state the identity provider returned.
     * @param authorizationCode The authorization code generated by the identity provider.
     */
    public CompletableFuture<TokensResponse> exchangeAuthorizationCode(final String provider, final String state,
                                                                       final String authorizationCode) {
        final OAuthServiceClient client = Optional.ofNullable(providersClients.get(provider))
                .orElseThrow(() -> new ServiceException(ErrorCode.GENERIC_AUTH_FAILURE, "Invalid identity provider"));

        return sessionsRepository.getById(state)
                .thenCompose(sessionOptional -> {
                    return sessionOptional.map(session -> {
                        if (session.getExpiresAt().isAfter(ZonedDateTime.now())) {
                            return client.authorize(authorizationCode);
                        } else {
                            throw new ServiceAuthorizationException(ErrorCode.TOKEN_EXPIRED_OR_DOES_NOT_EXIST,
                                    "The provided state is either invalid or has expired");
                        }
                    }).orElseThrow(() -> new ServiceAuthorizationException(ErrorCode.TOKEN_EXPIRED_OR_DOES_NOT_EXIST,
                            "The provided state is either invalid or has expired"));
                });
    }

    private Map<String, OAuthServiceClient> createClients(final List<ImmutableOAuthClientConfiguration> clientsConfigs) {
        return clientsConfigs.stream()
                .map(clientConfig -> Maps.immutableEntry(clientConfig.getProvider(), new OAuthServiceClient(clientConfig)))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }
}

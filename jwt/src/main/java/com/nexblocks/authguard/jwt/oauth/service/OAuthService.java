package com.nexblocks.authguard.jwt.oauth.service;

import com.auth0.jwt.JWT;
import com.auth0.jwt.interfaces.Claim;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.google.common.collect.Maps;
import com.google.inject.Inject;
import com.google.inject.name.Named;
import com.nexblocks.authguard.config.ConfigContext;
import com.nexblocks.authguard.jwt.oauth.OAuthServiceClient;
import com.nexblocks.authguard.jwt.oauth.ResponseType;
import com.nexblocks.authguard.jwt.oauth.TokensResponse;
import com.nexblocks.authguard.jwt.oauth.config.ImmutableOAuthClientConfiguration;
import com.nexblocks.authguard.jwt.oauth.config.ImmutableOAuthConfiguration;
import com.nexblocks.authguard.service.AccountsService;
import com.nexblocks.authguard.service.SessionsService;
import com.nexblocks.authguard.service.exceptions.ServiceAuthorizationException;
import com.nexblocks.authguard.service.exceptions.ServiceException;
import com.nexblocks.authguard.service.exceptions.codes.ErrorCode;
import com.nexblocks.authguard.service.model.AccountBO;
import com.nexblocks.authguard.service.model.AccountEmailBO;
import com.nexblocks.authguard.service.model.RequestContextBO;
import com.nexblocks.authguard.service.model.SessionBO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import io.smallrye.mutiny.Uni;
import java.util.stream.Collectors;

public class OAuthService {
    private static final Logger LOG = LoggerFactory.getLogger(OAuthService.class);

    private final Map<String, OAuthServiceClient> providersClients;
    private final SessionsService sessionsService;
    private final AccountsService accountsService;
    private final Duration stateTtl;

    @Inject
    public OAuthService(final @Named("oauth") ConfigContext configContext,
                        final SessionsService sessionsService,
                        final AccountsService accountsService) {
        this(configContext.asConfigBean(ImmutableOAuthConfiguration.class), sessionsService, accountsService);
    }

    public OAuthService(final ImmutableOAuthConfiguration configuration,
                        final SessionsService sessionsService,
                        final AccountsService accountsService) {
        this.sessionsService = sessionsService;

        this.providersClients = createClients(configuration.getClients());
        this.accountsService = accountsService;
        this.stateTtl = Duration.ofMinutes(5);
    }

    /**
     * Creates an authorization URL to be sent to the client to redirect
     * it to the identity provider authorization page. It generates a
     * new temporary session to store the state to be verified later.
     *
     * @param provider The name of a provider as stated in the configuration.
     */
    public Uni<String> getAuthorizationUrl(final String provider) {
        OAuthServiceClient client = Optional.ofNullable(providersClients.get(provider))
                .orElseThrow(() -> new ServiceException(ErrorCode.GENERIC_AUTH_FAILURE, "Invalid identity provider"));
        SessionBO session = SessionBO.builder()
                .expiresAt(Instant.now().plus(stateTtl))
                .build();

        return sessionsService.create(session)
                .map(created -> client.createAuthorizationUrl(created.getSessionToken(), ResponseType.CODE));
    }

    /**
     * Exchanges an authorization code with OAuth tokens. It'll verify that
     * a session containing that state exists before performing the exchange.
     * If the state has expired or no record of it existed then the future
     * will complete with {@link ServiceAuthorizationException}.
     *
     * @param provider The name of a provider as stated in the configuration.
     * @param state The state the identity provider returned.
     * @param authorizationCode The authorization code generated by the identity provider.
     */
    public Uni<TokensResponse> exchangeAuthorizationCode(final String provider, final String state,
                                                                       final String authorizationCode) {
        OAuthServiceClient client = Optional.ofNullable(providersClients.get(provider))
                .orElseThrow(() -> new ServiceException(ErrorCode.GENERIC_AUTH_FAILURE, "Invalid identity provider"));

        return sessionsService.getByToken(state)
                .flatMap(sessionOptional -> sessionOptional
                        .map(session -> doExchange(client, authorizationCode, session))
                        .orElseThrow(() ->
                                new ServiceAuthorizationException(ErrorCode.TOKEN_EXPIRED_OR_DOES_NOT_EXIST,
                                        "The provided state is either invalid or has expired")))
                .flatMap(tokensResponse -> {
                    if (client.getConfiguration().isAccountProvider()) {
                        if (tokensResponse.getIdToken() == null) {
                            LOG.warn("Provider {} was set as an account provider but no ID was found in the response", provider);
                            return Uni.createFrom().item(tokensResponse);
                        }
                        return getOrCreateAccount(client, authorizationCode, tokensResponse.getIdToken())
                                .map(account -> {
                                    tokensResponse.setAccountId(account.getId());
                                    return tokensResponse;
                                });
                    }

                    return Uni.createFrom().item(tokensResponse);
                });
    }

    private Map<String, OAuthServiceClient> createClients(final List<ImmutableOAuthClientConfiguration> clientsConfigs) {
        return clientsConfigs.stream()
                .map(clientConfig -> Maps.immutableEntry(clientConfig.getProvider(), new OAuthServiceClient(clientConfig)))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    private Uni<TokensResponse> doExchange(final OAuthServiceClient client,
                                                         final String authorizationCode,
                                                         final SessionBO session) {
        if (session.getExpiresAt().isAfter(Instant.now())) {
            return client.authorize(authorizationCode);
        } else {
            throw new ServiceAuthorizationException(ErrorCode.TOKEN_EXPIRED_OR_DOES_NOT_EXIST,
                    "The provided state is either invalid or has expired");
        }
    }

    private Uni<AccountBO> getOrCreateAccount(final OAuthServiceClient serviceClient,
                                                            final String authorizationCode,
                                                            final String idToken) {
        ImmutableOAuthClientConfiguration configuration = serviceClient.getConfiguration();

        DecodedJWT decoded = JWT.decode(idToken);
        String externalId = decoded.getSubject();

        return accountsService.getByExternalIdUnchecked(externalId)
                .flatMap(account -> {
                    if (account.isPresent()) {
                        return Uni.createFrom().item(account.get());
                    }

                    AccountBO.Builder newAccount = AccountBO.builder()
                            .externalId(externalId)
                            .social(true)
                            .identityProvider(configuration.getProvider());

                    if (configuration.getEmailField() != null) {
                        Claim emailClaim = decoded.getClaim(configuration.getEmailField());

                        if (!emailClaim.isNull()) {
                            newAccount.email(AccountEmailBO.builder()
                                    .email(emailClaim.asString())
                                    .build());
                        }
                    }

                    RequestContextBO requestContext = RequestContextBO.builder()
                            .source(configuration.getProvider())
                            .idempotentKey(authorizationCode)
                            .build();

                    return accountsService.create(newAccount.build(), requestContext);
                });
    }
}
